#!/usr/bin/perl

use strict;
use warnings;

use POSIX;
use File::Path;
use DB_File;
use Storable;
use HTML::Entities;
use URI::Escape;
use Locale::gettext;
use Compress::Zlib;

use lib './lib';

use Packages::Config qw( $TOPDIR $DBDIR @ARCHIVES @SUITES @LANGUAGES $LOCALES);
use Packages::Template;
use Packages::I18N::Locale;
use Packages::Page;
use Packages::SrcPage;
use Packages::Sections;
&Packages::Config::init( './' );

delete $ENV{'LANGUAGE'};
delete $ENV{'LANG'};
delete $ENV{'LC_ALL'};
delete $ENV{'LC_MESSAGES'};
bindtextdomain ( 'pdo', $LOCALES );
bindtextdomain ( 'sections', $LOCALES );
textdomain( 'pdo' );

my $wwwdir = "$TOPDIR/www";

tie my %packages, 'DB_File', "$DBDIR/packages_small.db",
    O_RDONLY, 0666, $DB_BTREE
    or die "couldn't tie DB $DBDIR/packages_small.db: $!";
tie my %src_packages, 'DB_File', "$DBDIR/sources_small.db",
    O_RDONLY, 0666, $DB_BTREE
    or die "couldn't tie DB $DBDIR/sources_small.db: $!";
tie my %src2bin, 'DB_File', "$DBDIR/sources_packages.db",
    O_RDONLY, 0666, $DB_BTREE
    or die "couldn't open $DBDIR/sources_packages.db: $!";

my $sections = retrieve "$DBDIR/sections.info";
my $subsections = retrieve "$DBDIR/subsections.info";
my $priorities = retrieve "$DBDIR/priorities.info";

#use Data::Dumper;
#print STDERR Dumper($sections, $subsections, $priorities);

my (%pages, %tt_vars);

$tt_vars{make_search_url} = sub { return &Packages::CGI::make_search_url(@_) };
$tt_vars{make_url} = sub { return &Packages::CGI::make_url(@_) };
# needed to work around the limitations of the the FILTER syntax
$tt_vars{html_encode} = sub { return HTML::Entities::encode_entities(@_,'<>&"') };
$tt_vars{uri_escape} = sub { return URI::Escape::uri_escape(@_) };
$tt_vars{quotemeta} = sub { return quotemeta($_[0]) };

my $template = new Packages::Template( "$TOPDIR/templates", 'html', \%tt_vars );

print "write suite index files ...\n";
foreach my $s (@SUITES) {
    my $key = $s;
    mkpath ( "$wwwdir/$key" );
    mkpath ( "$wwwdir/source/$key" );
    foreach my $lang (@LANGUAGES) {
	my $locale = get_locale( $lang );
	my $charset = get_locale( $lang );
	setlocale ( LC_ALL, $locale ) or do {
	    warn "couldn't set locale ($lang/$locale)\n";
	    next;
	};
	print "writing $key/index (lang=$lang)...\n";

	my %content = ( subsections => [], suite => $s,
			lang => $lang, charset => $charset,
			used_langs => \@LANGUAGES, suites => \@SUITES );
	foreach my $ssec ((keys %{$subsections->{$s}}, 'virtual')) {
	    next if $ssec eq '-';
	    if ($sections_descs{$ssec}) {
		push @{$content{subsections}}, {
		    id => $ssec,
		    name => dgettext( 'sections', $sections_descs{$ssec}[0] ),
		    desc => dgettext( 'sections', $sections_descs{$ssec}[1] ),
		};
	    }
	}

	open $pages{$key}{$lang}{index}{fh}, '>', "$wwwdir/$key/index.$lang.html.new"
	    or die "can't open index file for output: $!";
	print {$pages{$key}{$lang}{index}{fh}} $template->page( 'suite_index', \%content );
	close $pages{$key}{$lang}{index}{fh} or
	    warn "can't close index file $wwwdir/$key/index.$lang.html.new: $!";
	rename( "$wwwdir/$key/index.$lang.html.new",
		"$wwwdir/$key/index.$lang.html" );

	$content{source} = 'source';
	open $pages{$key}{$lang}{source_index}{fh}, '>', "$wwwdir/source/$key/index.$lang.html.new"
	    or die "can't open index file for output: $!";
	print {$pages{$key}{$lang}{source_index}{fh}} $template->page( 'suite_index', \%content );
	close $pages{$key}{$lang}{source_index}{fh} or
	    warn "can't close index file $wwwdir/source/$key/index.$lang.html.new: $!";
	rename( "$wwwdir/source/$key/index.$lang.html.new",
		"$wwwdir/source/$key/index.$lang.html" );

    }
}
setlocale( LC_ALL, 'C' ) or die "couldn't reset locale";

print "collecting package info ...\n";
my %allpkgs;
while (my ($pkg, $data) = each %packages) {
    my (%pkg,%virt);
    my ($virt, $p_data) = split /\000/o, $data, 2;
    %virt = split /\01/o, $virt; 
    foreach (split /\000/o, $p_data||'') {
	my @data = split ( /\s/o, $_, 8 );
	$pkg{$data[1]} ||= new Packages::Page( $pkg );
	$pkg{$data[1]}->merge_package( { package => $pkg,
					 archive => $data[0],
					 suite => $data[1],
					 architecture => $data[2],
					 section => $data[3],
					 subsection => $data[4],
					 priority => $data[5],
					 version => $data[6],
					 description => $data[7] } );
    }
    foreach (keys %virt) {
	next if $_ eq '-';
	$pkg{$_} ||= new Packages::Page( $pkg );
	$pkg{$_}->add_provided_by([split /\s+/, $virt{$_}]);
    }

    while (my ($key, $entry) = each %pkg) {
	$allpkgs{$key} ||= [];

	my %p = ( name => $pkg, providers => [], versions => '' );
	if (my $provided_by = $entry->{provided_by}) {
	    $p{providers} = $provided_by;
 	}
	$p{subsection} = $p{section} = $p{archive} = $p{desc} = $p{priority} = '';
 	unless ($entry->is_virtual) {
	    (undef, $p{versions}) = $entry->get_version_string;
	    $p{subsection} = $entry->get_newest( 'subsection' );
	    $p{section} = $entry->get_newest( 'section' );
	    $p{archive} = $entry->get_newest( 'archive' );
	    $p{desc} = $entry->get_newest( 'description' );
	    $p{priority} = $entry->get_newest( 'priority' );
	}
	push @{$allpkgs{$key}}, \%p;
    }
}

write_files(\%allpkgs);

print "collecting source package info ...\n";
my %allsrcpkgs;
while (my ($pkg, $data) = each %src_packages) {
    my %pkg;    
    foreach (split /\000/o, $data||'') {
	my @data = split ( /\s/o, $_ );
	$pkg{$data[1]} ||= new Packages::SrcPage( $pkg );
	$pkg{$data[1]}->merge_package( { package => $pkg,
					 archive => $data[0],
					 suite => $data[1],
					 section => $data[2],
					 subsection => $data[3],
					 priority => $data[4],
					 version => $data[5],
					 } );
    }

    while (my ($key, $entry) = each %pkg) {
	$allsrcpkgs{$key} ||= [];

	my %p = ( name => $pkg, providers => [], versions => '' );
	$p{versions} = $entry->{version};
	$p{subsection} = $entry->get_newest( 'subsection' );
	$p{section} = $entry->get_newest( 'section' );
	$p{archive} = $entry->get_newest( 'archive' );
	$p{priority} = $entry->get_newest( 'priority' );
	
	$p{desc} = '';
 	$p{binaries} = [];
# 	my $binaries = find_binaries( $pkg, $p{archive}, $p{suite}, \%src2bin );
# 	if ($binaries && @$binaries) {
# 	    pkg_list( \%packages, $opts, $binaries, 'en', $contents{binaries} );
# 	}

	push @{$allsrcpkgs{$key}}, \%p;
    }
}

write_files(\%allsrcpkgs, 1);

sub write_files {
    my ($pkgs, $source) = @_;

    $source = $source ? 'source/' : '';
    print "writing files ...\n";
    foreach my $s (@SUITES) {
	my $key = $s;
	mkpath ( "$wwwdir/$source$key" );
	print "writing $source$s/allpackages...\n";
	$template->process( 'html/index.tmpl', { packages => $pkgs->{$key}, suite => $s, lang => 'en', is_source => $source  },
			    "$wwwdir/$source$key/allpackages.en.html.new" )
	    or die "error writing allpackages for $key: ".$template->error();
	print "writing $source$s/allpackages (txt)...\n";
	my $gzfh = gzopen("$wwwdir/$source$key/allpackages.en.txt.gz.new",
		      'wb9')
	    or die "can't open text index file for output: $!";
	my $gztxt;
	$template->process( 'txt/index.tmpl', { packages => $pkgs->{$key}, suite => $s, lang => 'en', is_source => $source  },
			    \$gztxt )
	    or die "error writing allpackages txt for $key: ".$template->error();    
	$gzfh->gzwrite($gztxt);
	($gzfh->gzclose == Z_OK) or
	    warn "can't close text index file $wwwdir/$source$key/allpackages.en.txt.gz.new: ".$gzfh->gzerror;

	rename( "$wwwdir/$source$key/allpackages.en.html.new",
		"$wwwdir/$source$key/allpackages.en.html" );
	rename( "$wwwdir/$source$key/allpackages.en.txt.gz.new",
		"$wwwdir/$source$key/allpackages.en.txt.gz" );
	
	foreach my $sec (keys %{$sections->{$s}}) {
	    mkpath ( "$wwwdir/$source$key/$sec" );

	    print "writing $source$s/$sec/index...\n";
	    $template->process( 'html/index.tmpl', { packages => [ grep { $_->{section} eq $sec } @{$pkgs->{$key}} ],
						     suite => $s, lang => 'en', is_source => $source,
						     category => { id => 'section', name => $sec } },
				"$wwwdir/$source$key/$sec/index.en.html.new" )
		or die "error writing section index for $key/$sec: ".$template->error();
	    rename( "$wwwdir/$source$key/$sec/index.en.html.new",
		    "$wwwdir/$source$key/$sec/index.en.html" );
    }
	foreach my $ssec ((keys %{$subsections->{$s}}, 'virtual')) {
	    next if $ssec eq '-';
	    mkpath ( "$wwwdir/$source$key/$ssec" );

	    print "writing $source$s/$ssec/index...\n";
	    $template->process( 'html/index.tmpl', { packages => [ grep { $_->{subsection} eq $ssec } @{$pkgs->{$key}} ],
						     suite => $s, lang => 'en', is_source => $source,
						     category => { id => 'subsection', name => $ssec } },
				"$wwwdir/$source$key/$ssec/index.en.html.new" )
	    or die "error writing subsection index for $key/$ssec: ".$template->error();
	rename( "$wwwdir/$source$key/$ssec/index.en.html.new",
		"$wwwdir/$source$key/$ssec/index.en.html" );
	}
	foreach my $prio (keys %{$priorities->{$s}}) {
	    next if $prio eq '-';
	    mkpath ( "$wwwdir/$source$key/$prio" );
	    
	    print "writing $source$s/$prio/index...\n";
	    $template->process( 'html/index.tmpl', { packages => [ grep { $_->{priority} eq $prio } @{$pkgs->{$key}} ],
						     suite => $s, lang => 'en', is_source => $source,
						     category => { id => 'priority', name => $prio } },
				"$wwwdir/$source$key/$prio/index.en.html.new" )
		or die "error writing priority index for $key/$prio: ".$template->error();
	    rename( "$wwwdir/$source$key/$prio/index.en.html.new",
		    "$wwwdir/$source$key/$prio/index.en.html" );
	}
    }
}
